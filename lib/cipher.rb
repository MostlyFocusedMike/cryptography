require_relative './common_words.rb'
require 'pry'
class Encoder
  ALPHABET = ["a","b","c","d","e","f","g","h","i","j","k","l", "m","n",'o','p','q',
              'r','s','t','u','v','w','x', 'y','z']

  attr_accessor :cipher, :msg, :encoded_msg, :newly_decoded_msg, :matches, :misses,
    :newly_encoded_msg, :fin_decoded_msg
  def initialize
    self.make_cipher
    @matches = @misses = []
  end

  def get_user_msg
    @msg = gets.strip
  end

  def get_user_encoded_msg
    @encoded_msg = gets.strip
  end

  def make_cipher
    @cipher = rand(1..25)
  end

  def string_prep(str) 
    return str.split("")
  end

  def capital?(letter)
    return /[[:upper:]]/.match(letter) ? true : false
  end

  def non_letter?(letter)
    return /[[a-zA-Z]]/.match(letter.to_s) ? false : true 
  end

  # scramble refers to internal encoding and decoding, while encode and decode are
  # reserved for functions that actually interact with the user 
  # and msg and encoded_msg refer to user entered input, while newly_encoded_msg and 
  # newly_decoded_msg refer to encrypted and decrypted messages generated by functions 

  def scramble_letter(letter, move)
    return letter if non_letter?(letter)
    index = ALPHABET.index(letter.downcase)
    move.times do
      index += 1 
      index = index > 25 ? 0 : index  
    end 
    return capital?(letter) ? ALPHABET[index].upcase : ALPHABET[index]
  end

  def scramble_msg
    msg_array = string_prep(@msg)
    @newly_encoded_msg = msg_array.map do |char| 
      scramble_letter(char,@cipher)
    end.join("")
  end

  def roll_back_letter(letter)
    return letter if non_letter?(letter)
    index = ALPHABET.index(letter.downcase)
    index -= 1 
    index = index < 0 ? 25 : index  
    return capital?(letter) ? ALPHABET[index].upcase : ALPHABET[index]
  end

  def roll_back_message
    encoded_array = string_prep(@encoded_msg)
    @newly_decoded_msg = encoded_array.map do |char|
      roll_back_letter(char)
    end.join("")
  end

  def has_words? 
    # returns true if any eng
    @newly_decoded_msg.split.any? do |word|
      word = word.match(/\b(\w+)\b/)[0]
      COMMON_WORDS.include?(word.downcase)
    end
  end

  def count_words 
    @newly_decoded_msg.split.count do |word|
      word = word.match(/\b(\w+)\b/)[0]
      COMMON_WORDS.include?(word.downcase) 
    end
  end

  def sort_phrase
    if self.has_words?
      wc = self.count_words
      self.matches.push({msg: @newly_decoded_msg, wc: wc})
    end
  end 

  def fill_matches_misses
    25.times do 
      self.roll_back_message
      self.sort_phrase
      @encoded_msg = @newly_decoded_msg
    end
  end
  # basically the "run" method of the class
  def encode_user_msg
    # these two are either generated at this point, or accept 
    # previously given values to aid with testing
    @msg ||= self.get_user_msg 
    @cipher ||= self.make_cipher
    self.scramble_msg
    puts "#{@newly_encoded_msg}\n\tcipher: #{@cipher}"
  end

  def decode_user_msg
    @encoded_msg ||= self.get_user_encoded_msg
    self.fill_matches_misses
    self.fin_decoded_msg = self.matches.sort_by {|match| match[:wc]}[-1][:msg]
  end

end

def run
  print "Enter your message here: "
  encoder = Encoder.new 
  encoder.encode_user_msg
  encoder.decode_user_msg
  puts encoder.fin_decoded_msg
end
